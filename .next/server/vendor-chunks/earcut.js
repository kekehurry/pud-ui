"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/earcut";
exports.ids = ["vendor-chunks/earcut"];
exports.modules = {

/***/ "(ssr)/./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\nfunction earcut(data, holeIndices, dim) {\n    dim = dim || 2;\n    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    var minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n        for(var i = dim; i < outerLen; i += dim){\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n}\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n    if (clockwise === signedArea(data, start, end, dim) > 0) {\n        for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);\n    }\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n    return last;\n}\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n    var p = start, again;\n    do {\n        again = false;\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n        } else {\n            p = p.next;\n        }\n    }while (again || p !== end);\n    return end;\n}\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n    var stop = ear, prev, next;\n    // iterate through ears, slicing them one by one\n    while(ear.prev !== ear.next){\n        prev = ear.prev;\n        next = ear.next;\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n            removeNode(ear);\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n            continue;\n        }\n        ear = next;\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n            break;\n        }\n    }\n}\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    var p = c.next;\n    while(p !== a){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n    return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);\n    var p = ear.prevZ, n = ear.nextZ;\n    // look for points inside the triangle in both directions\n    while(p && p.z >= minZ && n && n.z <= maxZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    // look for remaining points in decreasing z-order\n    while(p && p.z >= minZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n    // look for remaining points in increasing z-order\n    while(n && n.z <= maxZ){\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    return true;\n}\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev, b = p.next.next;\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n            p = start = b;\n        }\n        p = p.next;\n    }while (p !== start);\n    return filterPoints(p);\n}\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while(b !== a.prev){\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    }while (a !== start);\n}\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [], i, len, start, end, list;\n    for(i = 0, len = holeIndices.length; i < len; i++){\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n    queue.sort(compareX);\n    // process holes from left to right\n    for(i = 0; i < queue.length; i++){\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n    return outerNode;\n}\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n    var bridgeReverse = splitPolygon(bridge, hole);\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    }while (p !== outerNode);\n    if (!m) return null;\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;\n    p = m;\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n        p = p.next;\n    }while (p !== stop);\n    return m;\n}\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    }while (p !== start);\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n    sortLinked(p);\n}\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n        while(p){\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for(i = 0; i < inSize; i++){\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n            while(pSize > 0 || qSize > 0 && q){\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n                if (tail) tail.nextZ = e;\n                else list = e;\n                e.prevZ = tail;\n                tail = e;\n            }\n            p = q;\n        }\n        tail.nextZ = null;\n        inSize *= 2;\n    }while (numMerges > 1);\n    return list;\n}\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n    x = (x | x << 8) & 0x00FF00FF;\n    x = (x | x << 4) & 0x0F0F0F0F;\n    x = (x | x << 2) & 0x33333333;\n    x = (x | x << 1) & 0x55555555;\n    y = (y | y << 8) & 0x00FF00FF;\n    y = (y | y << 4) & 0x0F0F0F0F;\n    y = (y | y << 2) & 0x33333333;\n    y = (y | y << 1) & 0x55555555;\n    return x | y << 1;\n}\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start, leftmost = start;\n    do {\n        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n        p = p.next;\n    }while (p !== start);\n    return leftmost;\n}\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n    return false;\n}\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    }while (p !== a);\n    return false;\n}\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\n    do {\n        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n        p = p.next;\n    }while (p !== a);\n    return inside;\n}\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\n    a.next = b;\n    b.prev = a;\n    a2.next = an;\n    an.prev = a2;\n    b2.next = a2;\n    a2.prev = b2;\n    bp.next = b2;\n    b2.prev = bp;\n    return b2;\n}\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n    // z-order curve value\n    this.z = 0;\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function(data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for(var i = 0, len = holeIndices.length; i < len; i++){\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n    var trianglesArea = 0;\n    for(i = 0; i < triangles.length; i += 3){\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for(var i = start, j = end - dim; i < end; i += dim){\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function(data) {\n    var dim = data[0][0].length, result = {\n        vertices: [],\n        holes: [],\n        dimensions: dim\n    }, holeIndex = 0;\n    for(var i = 0; i < data.length; i++){\n        for(var j = 0; j < data[i].length; j++){\n            for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHQztBQUNqQkYseUJBQXNCLEdBQUdFO0FBRXpCLFNBQVNBLE9BQU9FLElBQUksRUFBRUMsV0FBVyxFQUFFQyxHQUFHO0lBRWxDQSxNQUFNQSxPQUFPO0lBRWIsSUFBSUMsV0FBV0YsZUFBZUEsWUFBWUcsTUFBTSxFQUM1Q0MsV0FBV0YsV0FBV0YsV0FBVyxDQUFDLEVBQUUsR0FBR0MsTUFBTUYsS0FBS0ksTUFBTSxFQUN4REUsWUFBWUMsV0FBV1AsTUFBTSxHQUFHSyxVQUFVSCxLQUFLLE9BQy9DTSxZQUFZLEVBQUU7SUFFbEIsSUFBSSxDQUFDRixhQUFhQSxVQUFVRyxJQUFJLEtBQUtILFVBQVVJLElBQUksRUFBRSxPQUFPRjtJQUU1RCxJQUFJRyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxHQUFHQyxHQUFHQztJQUVsQyxJQUFJZCxVQUFVRyxZQUFZWSxlQUFlbEIsTUFBTUMsYUFBYUssV0FBV0o7SUFFdkUsNkZBQTZGO0lBQzdGLElBQUlGLEtBQUtJLE1BQU0sR0FBRyxLQUFLRixLQUFLO1FBQ3hCUyxPQUFPRSxPQUFPYixJQUFJLENBQUMsRUFBRTtRQUNyQlksT0FBT0UsT0FBT2QsSUFBSSxDQUFDLEVBQUU7UUFFckIsSUFBSyxJQUFJbUIsSUFBSWpCLEtBQUtpQixJQUFJZCxVQUFVYyxLQUFLakIsSUFBSztZQUN0Q2EsSUFBSWYsSUFBSSxDQUFDbUIsRUFBRTtZQUNYSCxJQUFJaEIsSUFBSSxDQUFDbUIsSUFBSSxFQUFFO1lBQ2YsSUFBSUosSUFBSUosTUFBTUEsT0FBT0k7WUFDckIsSUFBSUMsSUFBSUosTUFBTUEsT0FBT0k7WUFDckIsSUFBSUQsSUFBSUYsTUFBTUEsT0FBT0U7WUFDckIsSUFBSUMsSUFBSUYsTUFBTUEsT0FBT0U7UUFDekI7UUFFQSxrR0FBa0c7UUFDbEdDLFVBQVVHLEtBQUtDLEdBQUcsQ0FB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Q3BFO1FBQ0EsSUFBSXBILElBQUksR0FBRztZQUNQbUgsYUFBYXRJLElBQUksQ0FBQ21CLElBQUksRUFBRSxDQUFDZixNQUFNO1lBQy9COEgsT0FBT0UsS0FBSyxDQUFDMUYsSUFBSSxDQUFDNEY7UUFDdEI7SUFDSjtJQUNBLE9BQU9KO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2VsZXRvbi11aS8uL25vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcz83MzNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlIHx8IG91dGVyTm9kZS5uZXh0ID09PSBvdXRlck5vZGUucHJldikgcmV0dXJuIHRyaWFuZ2xlcztcblxuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuXG4gICAgaWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xuXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gODAgKiBkaW0pIHtcbiAgICAgICAgbWluWCA9IG1heFggPSBkYXRhWzBdO1xuICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICAgIGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMzI3NjcgLyBpbnZTaXplIDogMDtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgaSwgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcblxuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIGJyZWFrO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MpIHtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIGlmICghcGFzcyAmJiBpbnZTaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKGludlNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIDogaXNFYXIoZWFyKSkge1xuICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSB8IDApO1xuXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XG5cbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKGVhcikge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG4gICAgdmFyIGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciB4MCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTAgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgIHgxID0gYXggPiBieCA/IChheCA+IGN4ID8gYXggOiBjeCkgOiAoYnggPiBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KTtcblxuICAgIHZhciBwID0gYy5uZXh0O1xuICAgIHdoaWxlIChwICE9PSBhKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgdmFyIGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciB4MCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTAgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgIHgxID0gYXggPiBieCA/IChheCA+IGN4ID8gYXggOiBjeCkgOiAoYnggPiBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KTtcblxuICAgIC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XG4gICAgdmFyIG1pblogPSB6T3JkZXIoeDAsIHkwLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSxcbiAgICAgICAgbWF4WiA9IHpPcmRlcih4MSwgeTEsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHAgPSBlYXIucHJldlosXG4gICAgICAgIG4gPSBlYXIubmV4dFo7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG5cbiAgICAgICAgaWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAobiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXG4gICAgICAgICAgICBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltIHwgMCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gZmlsdGVyUG9pbnRzKHApO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIGJyaWRnZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG4gICAgaWYgKCFicmlkZ2UpIHtcbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcbiAgICB9XG5cbiAgICB2YXIgYnJpZGdlUmV2ZXJzZSA9IHNwbGl0UG9seWdvbihicmlkZ2UsIGhvbGUpO1xuXG4gICAgLy8gZmlsdGVyIGNvbGxpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgZmlsdGVyUG9pbnRzKGJyaWRnZVJldmVyc2UsIGJyaWRnZVJldmVyc2UubmV4dCk7XG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhicmlkZ2UsIGJyaWRnZS5uZXh0KTtcbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcbiAgICAgICAgICAgIGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuICAgICAgICAgICAgICAgIHF4ID0geDtcbiAgICAgICAgICAgICAgICBtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkgcmV0dXJuIG07IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxlZnRtb3N0IGVuZHBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbTtcblxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAobG9jYWxseUluc2lkZShwLCBob2xlKSAmJlxuICAgICAgICAgICAgICAgICh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIChwLnggPiBtLnggfHwgKHAueCA9PT0gbS54ICYmIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApKSkpKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RvcCk7XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gd2hldGhlciBzZWN0b3IgaW4gdmVydGV4IG0gY29udGFpbnMgc2VjdG9yIGluIHZlcnRleCBwIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5mdW5jdGlvbiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSB7XG4gICAgcmV0dXJuIGFyZWEobS5wcmV2LCBtLCBwLnByZXYpIDwgMCAmJiBhcmVhKHAubmV4dCwgbSwgbS5uZXh0KSA8IDA7XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gMCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gKHggLSBtaW5YKSAqIGludlNpemUgfCAwO1xuICAgIHkgPSAoeSAtIG1pblkpICogaW52U2l6ZSB8IDA7XG5cbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcbmZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgbGVmdG1vc3QgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnggPCBsZWZ0bW9zdC54IHx8IChwLnggPT09IGxlZnRtb3N0LnggJiYgcC55IDwgbGVmdG1vc3QueSkpIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpID49IChheCAtIHB4KSAqIChjeSAtIHB5KSAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgPj0gKGJ4IC0gcHgpICogKGF5IC0gcHkpICYmXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSA+PSAoY3ggLSBweCkgKiAoYnkgLSBweSk7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJiAvLyBkb25lcyd0IGludGVyc2VjdCBvdGhlciBlZGdlc1xuICAgICAgICAgICAobG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKSAmJiAvLyBsb2NhbGx5IHZpc2libGVcbiAgICAgICAgICAgIChhcmVhKGEucHJldiwgYSwgYi5wcmV2KSB8fCBhcmVhKGEsIGIucHJldiwgYikpIHx8IC8vIGRvZXMgbm90IGNyZWF0ZSBvcHBvc2l0ZS1mYWNpbmcgc2VjdG9yc1xuICAgICAgICAgICAgZXF1YWxzKGEsIGIpICYmIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpID4gMCAmJiBhcmVhKGIucHJldiwgYiwgYi5uZXh0KSA+IDApOyAvLyBzcGVjaWFsIHplcm8tbGVuZ3RoIGNhc2Vcbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICB2YXIgbzEgPSBzaWduKGFyZWEocDEsIHExLCBwMikpO1xuICAgIHZhciBvMiA9IHNpZ24oYXJlYShwMSwgcTEsIHEyKSk7XG4gICAgdmFyIG8zID0gc2lnbihhcmVhKHAyLCBxMiwgcDEpKTtcbiAgICB2YXIgbzQgPSBzaWduKGFyZWEocDIsIHEyLCBxMSkpO1xuXG4gICAgaWYgKG8xICE9PSBvMiAmJiBvMyAhPT0gbzQpIHJldHVybiB0cnVlOyAvLyBnZW5lcmFsIGNhc2VcblxuICAgIGlmIChvMSA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHAyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHAyIGFyZSBjb2xsaW5lYXIgYW5kIHAyIGxpZXMgb24gcDFxMVxuICAgIGlmIChvMiA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHEyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHEyIGFyZSBjb2xsaW5lYXIgYW5kIHEyIGxpZXMgb24gcDFxMVxuICAgIGlmIChvMyA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHAxLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHAxIGFyZSBjb2xsaW5lYXIgYW5kIHAxIGxpZXMgb24gcDJxMlxuICAgIGlmIChvNCA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHExLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHExIGFyZSBjb2xsaW5lYXIgYW5kIHExIGxpZXMgb24gcDJxMlxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBmb3IgY29sbGluZWFyIHBvaW50cyBwLCBxLCByLCBjaGVjayBpZiBwb2ludCBxIGxpZXMgb24gc2VnbWVudCBwclxuZnVuY3Rpb24gb25TZWdtZW50KHAsIHEsIHIpIHtcbiAgICByZXR1cm4gcS54IDw9IE1hdGgubWF4KHAueCwgci54KSAmJiBxLnggPj0gTWF0aC5taW4ocC54LCByLngpICYmIHEueSA8PSBNYXRoLm1heChwLnksIHIueSkgJiYgcS55ID49IE1hdGgubWluKHAueSwgci55KTtcbn1cblxuZnVuY3Rpb24gc2lnbihudW0pIHtcbiAgICByZXR1cm4gbnVtID4gMCA/IDEgOiBudW0gPCAwID8gLTEgOiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG4gICAgICAgICAgICAgICAgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSlcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gICAgdmFyIGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSksXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBiMjtcbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICAgIHZhciBwID0gbmV3IE5vZGUoaSwgeCwgeSk7XG5cbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgcC5wcmV2ID0gcDtcbiAgICAgICAgcC5uZXh0ID0gcDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHAubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgcC5wcmV2ID0gbGFzdDtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBwO1xuICAgICAgICBsYXN0Lm5leHQgPSBwO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShwKSB7XG4gICAgcC5uZXh0LnByZXYgPSBwLnByZXY7XG4gICAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XG5cbiAgICBpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG4gICAgaWYgKHAubmV4dFopIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xufVxuXG5mdW5jdGlvbiBOb2RlKGksIHgsIHkpIHtcbiAgICAvLyB2ZXJ0ZXggaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGV4IG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgIHRoaXMueiA9IDA7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XG5cbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZWFyY3V0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgdmFyIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIHBvbHlnb25BcmVhID0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCAwLCBvdXRlckxlbiwgZGltKSk7XG4gICAgaWYgKGhhc0hvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICB2YXIgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHBvbHlnb25BcmVhIC09IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVzQXJlYSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgYSA9IHRyaWFuZ2xlc1tpXSAqIGRpbTtcbiAgICAgICAgdmFyIGIgPSB0cmlhbmdsZXNbaSArIDFdICogZGltO1xuICAgICAgICB2YXIgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufTtcblxuZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgICAgICBqID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLy8gdHVybiBhIHBvbHlnb24gaW4gYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBmb3JtIChlLmcuIGFzIGluIEdlb0pTT04pIGludG8gYSBmb3JtIEVhcmN1dCBhY2NlcHRzXG5lYXJjdXQuZmxhdHRlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRpbSA9IGRhdGFbMF1bMF0ubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7dmVydGljZXM6IFtdLCBob2xlczogW10sIGRpbWVuc2lvbnM6IGRpbX0sXG4gICAgICAgIGhvbGVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSByZXN1bHQudmVydGljZXMucHVzaChkYXRhW2ldW2pdW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGhvbGVJbmRleCArPSBkYXRhW2kgLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQuaG9sZXMucHVzaChob2xlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJlYXJjdXQiLCJkZWZhdWx0IiwiZGF0YSIsImhvbGVJbmRpY2VzIiwiZGltIiwiaGFzSG9sZXMiLCJsZW5ndGgiLCJvdXRlckxlbiIsIm91dGVyTm9kZSIsImxpbmtlZExpc3QiLCJ0cmlhbmdsZXMiLCJuZXh0IiwicHJldiIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJ4IiwieSIsImludlNpemUiLCJlbGltaW5hdGVIb2xlcyIsImkiLCJNYXRoIiwibWF4IiwiZWFyY3V0TGlua2VkIiwic3RhcnQiLCJlbmQiLCJjbG9ja3dpc2UiLCJsYXN0Iiwic2lnbmVkQXJlYSIsImluc2VydE5vZGUiLCJlcXVhbHMiLCJyZW1vdmVOb2RlIiwiZmlsdGVyUG9pbnRzIiwicCIsImFnYWluIiwic3RlaW5lciIsImFyZWEiLCJlYXIiLCJwYXNzIiwiaW5kZXhDdXJ2ZSIsInN0b3AiLCJpc0Vhckhhc2hlZCIsImlzRWFyIiwicHVzaCIsImN1cmVMb2NhbEludGVyc2VjdGlvbnMiLCJzcGxpdEVhcmN1dCIsImEiLCJiIiwiYyIsImF4IiwiYngiLCJjeCIsImF5IiwiYnkiLCJjeSIsIngwIiwieTAiLCJ4MSIsInkxIiwicG9pbnRJblRyaWFuZ2xlIiwibWluWiIsInpPcmRlciIsIm1heFoiLCJwcmV2WiIsIm4iLCJuZXh0WiIsInoiLCJpbnRlcnNlY3RzIiwibG9jYWxseUluc2lkZSIsImlzVmFsaWREaWFnb25hbCIsInNwbGl0UG9seWdvbiIsInF1ZXVlIiwibGVuIiwibGlzdCIsImdldExlZnRtb3N0Iiwic29ydCIsImNvbXBhcmVYIiwiZWxpbWluYXRlSG9sZSIsImhvbGUiLCJicmlkZ2UiLCJmaW5kSG9sZUJyaWRnZSIsImJyaWRnZVJldmVyc2UiLCJoeCIsImh5IiwicXgiLCJJbmZpbml0eSIsIm0iLCJteCIsIm15IiwidGFuTWluIiwidGFuIiwiYWJzIiwic2VjdG9yQ29udGFpbnNTZWN0b3IiLCJzb3J0TGlua2VkIiwicSIsImUiLCJ0YWlsIiwibnVtTWVyZ2VzIiwicFNpemUiLCJxU2l6ZSIsImluU2l6ZSIsImxlZnRtb3N0IiwicHgiLCJweSIsImludGVyc2VjdHNQb2x5Z29uIiwibWlkZGxlSW5zaWRlIiwiciIsInAxIiwicDIiLCJxMSIsInEyIiwibzEiLCJzaWduIiwibzIiLCJvMyIsIm80Iiwib25TZWdtZW50IiwibWluIiwibnVtIiwiaW5zaWRlIiwiYTIiLCJOb2RlIiwiYjIiLCJhbiIsImJwIiwiZGV2aWF0aW9uIiwicG9seWdvbkFyZWEiLCJ0cmlhbmdsZXNBcmVhIiwic3VtIiwiaiIsImZsYXR0ZW4iLCJyZXN1bHQiLCJ2ZXJ0aWNlcyIsImhvbGVzIiwiZGltZW5zaW9ucyIsImhvbGVJbmRleCIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/earcut/src/earcut.js\n");

/***/ })

};
;