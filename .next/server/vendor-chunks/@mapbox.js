"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mapbox";
exports.ids = ["vendor-chunks/@mapbox"];
exports.modules = {

/***/ "(ssr)/./node_modules/@mapbox/tiny-sdf/index.js":
/*!************************************************!*\
  !*** ./node_modules/@mapbox/tiny-sdf/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TinySDF)\n/* harmony export */ });\nconst INF = 1e20;\nclass TinySDF {\n    constructor({ fontSize = 24, buffer = 3, radius = 8, cutoff = 0.25, fontFamily = \"sans-serif\", fontWeight = \"normal\", fontStyle = \"normal\" } = {}){\n        this.buffer = buffer;\n        this.cutoff = cutoff;\n        this.radius = radius;\n        // make the canvas size big enough to both have the specified buffer around the glyph\n        // for \"halo\", and account for some glyphs possibly being larger than their font size\n        const size = this.size = fontSize + buffer * 4;\n        const canvas = this._createCanvas(size);\n        const ctx = this.ctx = canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n        ctx.textBaseline = \"alphabetic\";\n        ctx.textAlign = \"left\"; // Necessary so that RTL text doesn't have different alignment\n        ctx.fillStyle = \"black\";\n        // temporary arrays for the distance transform\n        this.gridOuter = new Float64Array(size * size);\n        this.gridInner = new Float64Array(size * size);\n        this.f = new Float64Array(size);\n        this.z = new Float64Array(size + 1);\n        this.v = new Uint16Array(size);\n    }\n    _createCanvas(size) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = canvas.height = size;\n        return canvas;\n    }\n    draw(char) {\n        const { width: glyphAdvance, actualBoundingBoxAscent, actualBoundingBoxDescent, actualBoundingBoxLeft, actualBoundingBoxRight } = this.ctx.measureText(char);\n        // The integer/pixel part of the top alignment is encoded in metrics.glyphTop\n        // The remainder is implicitly encoded in the rasterization\n        const glyphTop = Math.ceil(actualBoundingBoxAscent);\n        const glyphLeft = 0;\n        // If the glyph overflows the canvas size, it will be clipped at the bottom/right\n        const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));\n        const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));\n        const width = glyphWidth + 2 * this.buffer;\n        const height = glyphHeight + 2 * this.buffer;\n        const len = Math.max(width * height, 0);\n        const data = new Uint8ClampedArray(len);\n        const glyph = {\n            data,\n            width,\n            height,\n            glyphWidth,\n            glyphHeight,\n            glyphTop,\n            glyphLeft,\n            glyphAdvance\n        };\n        if (glyphWidth === 0 || glyphHeight === 0) return glyph;\n        const { ctx, buffer, gridInner, gridOuter } = this;\n        ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);\n        ctx.fillText(char, buffer, buffer + glyphTop);\n        const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);\n        // Initialize grids outside the glyph range to alpha 0\n        gridOuter.fill(INF, 0, len);\n        gridInner.fill(0, 0, len);\n        for(let y = 0; y < glyphHeight; y++){\n            for(let x = 0; x < glyphWidth; x++){\n                const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n                if (a === 0) continue; // empty pixels\n                const j = (y + buffer) * width + x + buffer;\n                if (a === 1) {\n                    gridOuter[j] = 0;\n                    gridInner[j] = INF;\n                } else {\n                    const d = 0.5 - a;\n                    gridOuter[j] = d > 0 ? d * d : 0;\n                    gridInner[j] = d < 0 ? d * d : 0;\n                }\n            }\n        }\n        edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);\n        edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);\n        for(let i = 0; i < len; i++){\n            const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n            data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));\n        }\n        return glyph;\n    }\n}\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, x0, y0, width, height, gridSize, f, v, z) {\n    for(let x = x0; x < x0 + width; x++)edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);\n    for(let y = y0; y < y0 + height; y++)edt1d(data, y * gridSize + x0, 1, width, f, v, z);\n}\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n    v[0] = 0;\n    z[0] = -INF;\n    z[1] = INF;\n    f[0] = grid[offset];\n    for(let q = 1, k = 0, s = 0; q < length; q++){\n        f[q] = grid[offset + q * stride];\n        const q2 = q * q;\n        do {\n            const r = v[k];\n            s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;\n        }while (s <= z[k] && --k > -1);\n        k++;\n        v[k] = q;\n        z[k] = s;\n        z[k + 1] = INF;\n    }\n    for(let q = 0, k = 0; q < length; q++){\n        while(z[k + 1] < q)k++;\n        const r = v[k];\n        const qr = q - r;\n        grid[offset + q * stride] = f[r] + qr * qr;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcGJveC90aW55LXNkZi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsTUFBTTtBQUVHLE1BQU1DO0lBQ2pCQyxZQUFZLEVBQ1JDLFdBQVcsRUFBRSxFQUNiQyxTQUFTLENBQUMsRUFDVkMsU0FBUyxDQUFDLEVBQ1ZDLFNBQVMsSUFBSSxFQUNiQyxhQUFhLFlBQVksRUFDekJDLGFBQWEsUUFBUSxFQUNyQkMsWUFBWSxRQUFRLEVBQ3ZCLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDSixJQUFJLENBQUNMLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNFLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNELE1BQU0sR0FBR0E7UUFFZCxxRkFBcUY7UUFDckYscUZBQXFGO1FBQ3JGLE1BQU1LLE9BQU8sSUFBSSxDQUFDQSxJQUFJLEdBQUdQLFdBQVdDLFNBQVM7UUFFN0MsTUFBTU8sU0FBUyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0Y7UUFDbEMsTUFBTUcsTUFBTSxJQUFJLENBQUNBLEdBQUcsR0FBR0YsT0FBT0csVUFBVSxDQUFDLE1BQU07WUFBQ0Msb0JBQW9CO1FBQUk7UUFDeEVGLElBQUlHLElBQUksR0FBRyxDQUFDLEVBQUVQLFVBQVUsQ0FBQyxFQUFFRCxXQUFXLENBQUMsRUFBRUwsU0FBUyxHQUFHLEVBQUVJLFdBQVcsQ0FBQztRQUVuRU0sSUFBSUksWUFBWSxHQUFHO1FBQ25CSixJQUFJSyxTQUFTLEdBQUcsUUFBUSw4REFBOEQ7UUFDdEZMLElBQUlNLFNBQVMsR0FBRztRQUVoQiw4Q0FBOEM7UUFDOUMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSUMsYUFBYVgsT0FBT0E7UUFDekMsSUFBSSxDQUFDWSxTQUFTLEdBQUcsSUFBSUQsYUFBYVgsT0FBT0E7UUFDekMsSUFBSSxDQUFDYSxDQUFDLEdBQUcsSUFBSUYsYUFBYVg7UUFDMUIsSUFBSSxDQUFDYyxDQUFDLEdBQUcsSUFBSUgsYUFBYVgsT0FBTztRQUNq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QG1hcGJveC90aW55LXNkZi9pbmRleC5qcz84YzMyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IElORiA9IDFlMjA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbnlTREYge1xuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgZm9udFNpemUgPSAyNCxcbiAgICAgICAgYnVmZmVyID0gMyxcbiAgICAgICAgcmFkaXVzID0gOCxcbiAgICAgICAgY3V0b2ZmID0gMC4yNSxcbiAgICAgICAgZm9udEZhbWlseSA9ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgZm9udFdlaWdodCA9ICdub3JtYWwnLFxuICAgICAgICBmb250U3R5bGUgPSAnbm9ybWFsJ1xuICAgIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5jdXRvZmYgPSBjdXRvZmY7XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXG4gICAgICAgIC8vIG1ha2UgdGhlIGNhbnZhcyBzaXplIGJpZyBlbm91Z2ggdG8gYm90aCBoYXZlIHRoZSBzcGVjaWZpZWQgYnVmZmVyIGFyb3VuZCB0aGUgZ2x5cGhcbiAgICAgICAgLy8gZm9yIFwiaGFsb1wiLCBhbmQgYWNjb3VudCBmb3Igc29tZSBnbHlwaHMgcG9zc2libHkgYmVpbmcgbGFyZ2VyIHRoYW4gdGhlaXIgZm9udCBzaXplXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemUgPSBmb250U2l6ZSArIGJ1ZmZlciAqIDQ7XG5cbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHNpemUpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHt3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWV9KTtcbiAgICAgICAgY3R4LmZvbnQgPSBgJHtmb250U3R5bGV9ICR7Zm9udFdlaWdodH0gJHtmb250U2l6ZX1weCAke2ZvbnRGYW1pbHl9YDtcblxuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnOyAvLyBOZWNlc3Nhcnkgc28gdGhhdCBSVEwgdGV4dCBkb2Vzbid0IGhhdmUgZGlmZmVyZW50IGFsaWdubWVudFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcblxuICAgICAgICAvLyB0ZW1wb3JhcnkgYXJyYXlzIGZvciB0aGUgZGlzdGFuY2UgdHJhbnNmb3JtXG4gICAgICAgIHRoaXMuZ3JpZE91dGVyID0gbmV3IEZsb2F0NjRBcnJheShzaXplICogc2l6ZSk7XG4gICAgICAgIHRoaXMuZ3JpZElubmVyID0gbmV3IEZsb2F0NjRBcnJheShzaXplICogc2l6ZSk7XG4gICAgICAgIHRoaXMuZiA9IG5ldyBGbG9hdDY0QXJyYXkoc2l6ZSk7XG4gICAgICAgIHRoaXMueiA9IG5ldyBGbG9hdDY0QXJyYXkoc2l6ZSArIDEpO1xuICAgICAgICB0aGlzLnYgPSBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNhbnZhcyhzaXplKSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICBkcmF3KGNoYXIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgd2lkdGg6IGdseXBoQWR2YW5jZSxcbiAgICAgICAgICAgIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxuICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodFxuICAgICAgICB9ID0gdGhpcy5jdHgubWVhc3VyZVRleHQoY2hhcik7XG5cbiAgICAgICAgLy8gVGhlIGludGVnZXIvcGl4ZWwgcGFydCBvZiB0aGUgdG9wIGFsaWdubWVudCBpcyBlbmNvZGVkIGluIG1ldHJpY3MuZ2x5cGhUb3BcbiAgICAgICAgLy8gVGhlIHJlbWFpbmRlciBpcyBpbXBsaWNpdGx5IGVuY29kZWQgaW4gdGhlIHJhc3Rlcml6YXRpb25cbiAgICAgICAgY29uc3QgZ2x5cGhUb3AgPSBNYXRoLmNlaWwoYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQpO1xuICAgICAgICBjb25zdCBnbHlwaExlZnQgPSAwO1xuXG4gICAgICAgIC8vIElmIHRoZSBnbHlwaCBvdmVyZmxvd3MgdGhlIGNhbnZhcyBzaXplLCBpdCB3aWxsIGJlIGNsaXBwZWQgYXQgdGhlIGJvdHRvbS9yaWdodFxuICAgICAgICBjb25zdCBnbHlwaFdpZHRoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5zaXplIC0gdGhpcy5idWZmZXIsIE1hdGguY2VpbChhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IC0gYWN0dWFsQm91bmRpbmdCb3hMZWZ0KSkpO1xuICAgICAgICBjb25zdCBnbHlwaEhlaWdodCA9IE1hdGgubWluKHRoaXMuc2l6ZSAtIHRoaXMuYnVmZmVyLCBnbHlwaFRvcCArIE1hdGguY2VpbChhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpKTtcblxuICAgICAgICBjb25zdCB3aWR0aCA9IGdseXBoV2lkdGggKyAyICogdGhpcy5idWZmZXI7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGdseXBoSGVpZ2h0ICsgMiAqIHRoaXMuYnVmZmVyO1xuXG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KHdpZHRoICogaGVpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShsZW4pO1xuICAgICAgICBjb25zdCBnbHlwaCA9IHtkYXRhLCB3aWR0aCwgaGVpZ2h0LCBnbHlwaFdpZHRoLCBnbHlwaEhlaWdodCwgZ2x5cGhUb3AsIGdseXBoTGVmdCwgZ2x5cGhBZHZhbmNlfTtcbiAgICAgICAgaWYgKGdseXBoV2lkdGggPT09IDAgfHwgZ2x5cGhIZWlnaHQgPT09IDApIHJldHVybiBnbHlwaDtcblxuICAgICAgICBjb25zdCB7Y3R4LCBidWZmZXIsIGdyaWRJbm5lciwgZ3JpZE91dGVyfSA9IHRoaXM7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoYnVmZmVyLCBidWZmZXIsIGdseXBoV2lkdGgsIGdseXBoSGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXIsIGJ1ZmZlciwgYnVmZmVyICsgZ2x5cGhUb3ApO1xuICAgICAgICBjb25zdCBpbWdEYXRhID0gY3R4LmdldEltYWdlRGF0YShidWZmZXIsIGJ1ZmZlciwgZ2x5cGhXaWR0aCwgZ2x5cGhIZWlnaHQpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgZ3JpZHMgb3V0c2lkZSB0aGUgZ2x5cGggcmFuZ2UgdG8gYWxwaGEgMFxuICAgICAgICBncmlkT3V0ZXIuZmlsbChJTkYsIDAsIGxlbik7XG4gICAgICAgIGdyaWRJbm5lci5maWxsKDAsIDAsIGxlbik7XG5cbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBnbHlwaEhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGdseXBoV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpbWdEYXRhLmRhdGFbNCAqICh5ICogZ2x5cGhXaWR0aCArIHgpICsgM10gLyAyNTU7IC8vIGFscGhhIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IDApIGNvbnRpbnVlOyAvLyBlbXB0eSBwaXhlbHNcblxuICAgICAgICAgICAgICAgIGNvbnN0IGogPSAoeSArIGJ1ZmZlcikgKiB3aWR0aCArIHggKyBidWZmZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gMSkgeyAvLyBmdWxseSBkcmF3biBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgZ3JpZE91dGVyW2pdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZElubmVyW2pdID0gSU5GO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gYWxpYXNlZCBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IDAuNSAtIGE7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRPdXRlcltqXSA9IGQgPiAwID8gZCAqIGQgOiAwO1xuICAgICAgICAgICAgICAgICAgICBncmlkSW5uZXJbal0gPSBkIDwgMCA/IGQgKiBkIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlZHQoZ3JpZE91dGVyLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB3aWR0aCwgdGhpcy5mLCB0aGlzLnYsIHRoaXMueik7XG4gICAgICAgIGVkdChncmlkSW5uZXIsIGJ1ZmZlciwgYnVmZmVyLCBnbHlwaFdpZHRoLCBnbHlwaEhlaWdodCwgd2lkdGgsIHRoaXMuZiwgdGhpcy52LCB0aGlzLnopO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoZ3JpZE91dGVyW2ldKSAtIE1hdGguc3FydChncmlkSW5uZXJbaV0pO1xuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgucm91bmQoMjU1IC0gMjU1ICogKGQgLyB0aGlzLnJhZGl1cyArIHRoaXMuY3V0b2ZmKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2x5cGg7XG4gICAgfVxufVxuXG4vLyAyRCBFdWNsaWRlYW4gc3F1YXJlZCBkaXN0YW5jZSB0cmFuc2Zvcm0gYnkgRmVsemVuc3p3YWxiICYgSHV0dGVubG9jaGVyIGh0dHBzOi8vY3MuYnJvd24uZWR1L35wZmYvcGFwZXJzL2R0LWZpbmFsLnBkZlxuZnVuY3Rpb24gZWR0KGRhdGEsIHgwLCB5MCwgd2lkdGgsIGhlaWdodCwgZ3JpZFNpemUsIGYsIHYsIHopIHtcbiAgICBmb3IgKGxldCB4ID0geDA7IHggPCB4MCArIHdpZHRoOyB4KyspIGVkdDFkKGRhdGEsIHkwICogZ3JpZFNpemUgKyB4LCBncmlkU2l6ZSwgaGVpZ2h0LCBmLCB2LCB6KTtcbiAgICBmb3IgKGxldCB5ID0geTA7IHkgPCB5MCArIGhlaWdodDsgeSsrKSBlZHQxZChkYXRhLCB5ICogZ3JpZFNpemUgKyB4MCwgMSwgd2lkdGgsIGYsIHYsIHopO1xufVxuXG4vLyAxRCBzcXVhcmVkIGRpc3RhbmNlIHRyYW5zZm9ybVxuZnVuY3Rpb24gZWR0MWQoZ3JpZCwgb2Zmc2V0LCBzdHJpZGUsIGxlbmd0aCwgZiwgdiwgeikge1xuICAgIHZbMF0gPSAwO1xuICAgIHpbMF0gPSAtSU5GO1xuICAgIHpbMV0gPSBJTkY7XG4gICAgZlswXSA9IGdyaWRbb2Zmc2V0XTtcblxuICAgIGZvciAobGV0IHEgPSAxLCBrID0gMCwgcyA9IDA7IHEgPCBsZW5ndGg7IHErKykge1xuICAgICAgICBmW3FdID0gZ3JpZFtvZmZzZXQgKyBxICogc3RyaWRlXTtcbiAgICAgICAgY29uc3QgcTIgPSBxICogcTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgciA9IHZba107XG4gICAgICAgICAgICBzID0gKGZbcV0gLSBmW3JdICsgcTIgLSByICogcikgLyAocSAtIHIpIC8gMjtcbiAgICAgICAgfSB3aGlsZSAocyA8PSB6W2tdICYmIC0tayA+IC0xKTtcblxuICAgICAgICBrKys7XG4gICAgICAgIHZba10gPSBxO1xuICAgICAgICB6W2tdID0gcztcbiAgICAgICAgeltrICsgMV0gPSBJTkY7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcSA9IDAsIGsgPSAwOyBxIDwgbGVuZ3RoOyBxKyspIHtcbiAgICAgICAgd2hpbGUgKHpbayArIDFdIDwgcSkgaysrO1xuICAgICAgICBjb25zdCByID0gdltrXTtcbiAgICAgICAgY29uc3QgcXIgPSBxIC0gcjtcbiAgICAgICAgZ3JpZFtvZmZzZXQgKyBxICogc3RyaWRlXSA9IGZbcl0gKyBxciAqIHFyO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJJTkYiLCJUaW55U0RGIiwiY29uc3RydWN0b3IiLCJmb250U2l6ZSIsImJ1ZmZlciIsInJhZGl1cyIsImN1dG9mZiIsImZvbnRGYW1pbHkiLCJmb250V2VpZ2h0IiwiZm9udFN0eWxlIiwic2l6ZSIsImNhbnZhcyIsIl9jcmVhdGVDYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0Iiwid2lsbFJlYWRGcmVxdWVudGx5IiwiZm9udCIsInRleHRCYXNlbGluZSIsInRleHRBbGlnbiIsImZpbGxTdHlsZSIsImdyaWRPdXRlciIsIkZsb2F0NjRBcnJheSIsImdyaWRJbm5lciIsImYiLCJ6IiwidiIsIlVpbnQxNkFycmF5IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3IiwiY2hhciIsImdseXBoQWR2YW5jZSIsImFjdHVhbEJvdW5kaW5nQm94QXNjZW50IiwiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsIm1lYXN1cmVUZXh0IiwiZ2x5cGhUb3AiLCJNYXRoIiwiY2VpbCIsImdseXBoTGVmdCIsImdseXBoV2lkdGgiLCJtYXgiLCJtaW4iLCJnbHlwaEhlaWdodCIsImxlbiIsImRhdGEiLCJVaW50OENsYW1wZWRBcnJheSIsImdseXBoIiwiY2xlYXJSZWN0IiwiZmlsbFRleHQiLCJpbWdEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiZmlsbCIsInkiLCJ4IiwiYSIsImoiLCJkIiwiZWR0IiwiaSIsInNxcnQiLCJyb3VuZCIsIngwIiwieTAiLCJncmlkU2l6ZSIsImVkdDFkIiwiZ3JpZCIsIm9mZnNldCIsInN0cmlkZSIsImxlbmd0aCIsInEiLCJrIiwicyIsInEyIiwiciIsInFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mapbox/tiny-sdf/index.js\n");

/***/ })

};
;